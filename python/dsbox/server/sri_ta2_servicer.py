import core_pb2
import core_pb2_grpc
import logging
from google.protobuf.timestamp_pb2 import Timestamp
import random
import string
import os
import sys

import problem_pb2
import value_pb2

CURRENT_DIR = os.path.dirname(os.path.abspath(__file__))
sys.path.append(os.path.dirname(CURRENT_DIR))

import autoflowconfig
from core_pb2 import HelloResponse
from core_pb2 import SearchSolutionsResponse
from core_pb2 import GetSearchSolutionsResultsResponse
from core_pb2 import Progress
from core_pb2 import ProgressState
from core_pb2 import ScoreSolutionResponse
from core_pb2 import GetScoreSolutionResultsResponse
from core_pb2 import Score
from core_pb2 import EndSearchSolutionsResponse

from problem_pb2 import ProblemPerformanceMetric
from problem_pb2 import PerformanceMetric
from problem_pb2 import ProblemTarget

from value_pb2 import Value

logging.basicConfig(level=logging.DEBUG, format='%(asctime)s [%(levelname)s] %(name)s -- %(message)s')
_logger = logging.getLogger(__name__)


'''
This class implements the CoreServicer base class. The CoreServicer defines the methods that must be supported by a 
TA2 server implementation. The CoreServicer class is generated by grpc using the core.proto descriptor file. See:
https://gitlab.com/datadrivendiscovery/ta3ta2-api.  
'''
class TA2Servicer(core_pb2_grpc.CoreServicer):

    '''
    The __init__ method is used to establish the underlying TA2 libraries to service requests from the TA3 system.
    '''
    def __init__(self):
        self.log_msg("Init invoked")


    '''
    Hello call
    Non streaming call
    '''
    def Hello(self, request, context):
        self.log_msg(msg="Hello invoked")
        # TODO: Figure out what we should be sending back to TA3 here.
        return HelloResponse(user_agent="SRI",
                             version="1.3",
                             allowed_value_types="",
                             supported_extensions="")


    '''
    Search Solutions call
    Non streaming
    '''
    def SearchSolutions(self, request, context):
        self.log_msg(msg="SearchSolutions invoked")

        metric_index = request.problem.problem.performance_metrics[0].metric

        # Send request to TA2 search
        config_dict = dict(
            problemId = request.problem.problem.id,
            # TODO: Handle multiple metrics
            metric = problem_pb2.PerformanceMetric.Name(metric_index),
            taskType = request.problem.problem.task_type,
            # TODO: Handle multiple inputs
            datasetSchema = request.inputs[0].dataset_uri
        )

        # Initialize the TA2 config
        self.config = autoflowconfig.AutoflowConfig(config_dict=config_dict)

        # Based on the problem spec select an optimizer to use
        self.optimizer = self.config.select_optimizer()
        # Initiate the piepline generation
        self.optimizer.fit()

        return SearchSolutionsResponse(search_id=self.generateId())


    '''
    Get Search Solutions Results call
    Streams response to TA3
    '''
    def GetSearchSolutionsResults(self, request, context):
        self.log_msg(msg="GetSearchSolutionsResults invoked with search_id: " + request.search_id)
        # TODO: Read the pipelines we generated and munge them into the response for TA3
        timestamp = Timestamp()
        searchSolutionsResults = []
        searchSolutionsResults.append(GetSearchSolutionsResultsResponse(
            progress=Progress(state=core_pb2.COMPLETED,
            status="Done",
            start=timestamp.GetCurrentTime(),
            end=timestamp.GetCurrentTime()),
            done_ticks=0, # TODO: Figure out how we want to support this
            all_ticks=0, # TODO: Figure out how we want to support this
            solution_id="HIDOEI8973", # TODO: Populate this with the pipeline id
            internal_score=0,
            scores=None # Optional so we will not tackle it until needed
        ))
        # Add a second result to test streaming responses
        searchSolutionsResults.append(GetSearchSolutionsResultsResponse(
            progress=Progress(state=core_pb2.RUNNING,
            status="Done",
            start=timestamp.GetCurrentTime(),
            end=timestamp.GetCurrentTime()),
            done_ticks=0,
            all_ticks=0,
            solution_id="JIOEPB343", # TODO: Populate this with the pipeline id
            internal_score=0,
            scores=None
        ))
        for solution in searchSolutionsResults:
            yield solution


    '''
    Get the Score Solution request_id associated with the supplied solution_id
    Non streaming
    '''
    def ScoreSolution(self, request, context):
        self.log_msg(msg="ScoreSolution invoked with solution_id: " + request.solution_id)

        return ScoreSolutionResponse(
            # Generate valid request id 22 characters long for TA3 tracking
            request_id=self.generateId()
        )


    '''
    Get Score Solution Results call
    Streams response to TA3
    '''
    def GetScoreSolutionResults(self, request, context):
        self.log_msg(msg="GetScoreSolutionResults invoked with request_id: " + request.request_id)

        scoreSolutionResults = []
        timestamp = Timestamp()
        scoreSolutionResults.append(
            GetScoreSolutionResultsResponse(
            progress=Progress(state=core_pb2.COMPLETED,
                              status="Good",
                              start=timestamp.GetCurrentTime(),
                              end=timestamp.GetCurrentTime()),
            scores=[Score(metric=ProblemPerformanceMetric(metric=problem_pb2.ACCURACY,
                                            k = 0,
                                            pos_label="0"),
                          fold=0,
                          targets=[ProblemTarget(target_index=0,
                                           resource_id="0",
                                           column_index=0,
                                           column_name="0",
                                           clusters_number=0)],
                          value=Value(double=0.8))]
        ))
        scoreSolutionResults.append(GetScoreSolutionResultsResponse(
            progress=Progress(state=core_pb2.PENDING,
                              status="Good",
                              start=timestamp.GetCurrentTime(),
                              end=timestamp.GetCurrentTime()
        )))
        for score in scoreSolutionResults:
            yield score


    '''
    End the solution search process with the supplied search_id
    Non streaming
    '''
    def EndSearchSolutions(self, request, context):
        self.log_msg(msg="EndSearchSolutions invoked with search_id: " + request.search_id)

        return EndSearchSolutionsResponse()


    def GetProduceSolutionResults(self, request, context):
        pass


    def SolutionExport(self, request, context):
        pass


    def GetFitSolutionResults(self, request, context):
        pass


    def StopSearchSolutions(self, request, context):
        pass


    def ListPrimitives(self, request, context):
        pass


    def ProduceSolution(self, request, context):
        pass


    def FitSolution(self, request, context):
        pass


    def UpdateProblem(self, request, context):
        pass


    def DescribeSolution(self, request, context):
        pass


    '''
    Handy method for generating pipeline trace logs
    '''
    def log_msg(self, msg):
        msg = str(msg)
        for line in msg.splitlines():
            _logger.info("    | %s" % line)
        _logger.info("    \\_____________")


    '''
    Convenience method for generating 22 character id's
    '''
    def generateId(self):
        return ''.join(random.choice(string.ascii_uppercase + string.digits) for _ in range(22))
